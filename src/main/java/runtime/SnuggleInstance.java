package runtime;

import ast.ir.def.Program;
import exceptions.runtime.SnuggleException;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.util.TraceClassVisitor;

import java.io.PrintWriter;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * An instance of some compiled Snuggle code.
 * Encapsulates the concept of compiling and running said code.
 */
public class SnuggleInstance {

    //Jank temporary testing thing; instruction counter
    public static int INSTRUCTIONS = 0;

    //Generated by compiler
    private SnuggleRuntime runtime;

    //The class loader that holds all the generatedClasses for this instance
    private InstanceLoader loader;
//    private ErrorHelper errorHelper;

    public SnuggleInstance(Program.CompileResult compileResult) {
        loader = new InstanceLoader();
//        errorHelper = new ErrorHelper(compileResult, loader);

        for (Program.CompiledClass otherClass : compileResult.otherClasses()) {
            loader.defineClass(otherClass.bytes());
        }
        try {
            runtime = (SnuggleRuntime) loader.defineClass(compileResult.runtime().bytes()).getConstructor().newInstance();
        } catch (Exception impossible) {
            throw new IllegalStateException("Runtime always has default constructor, bug in compiler, please report!");
        }
    }

    /**
     * Runs the program. Any exceptions are processed to improve error messages,
     * and then thrown back out to the caller for their own handling.
     */
    public void run() throws SnuggleException {
//        try {
            runtime.run();
//        } catch (ClassCastException classCastException) {
//            throw errorHelper.translate(classCastException);
//        } catch (StackOverflowError stackOverflowError) {
//            throw errorHelper.translate(stackOverflowError);
//        } catch (SnuggleException snuggleException) {
//            throw errorHelper.translate(snuggleException);
//        }
    }

    //Just exposes a protected method for us
    private static class InstanceLoader extends ClassLoader {
        private static final AtomicInteger nextId = new AtomicInteger();
        private InstanceLoader() {
            super(
                    "SnuggleLoader" + nextId.getAndIncrement(),
                    getSystemClassLoader()
            );
        }

        private Class<?> defineClass(byte[] bytes) {
            new ClassReader(bytes).accept(new TraceClassVisitor(new PrintWriter(System.err)), ClassReader.SKIP_DEBUG);
            return defineClass(null, bytes, 0, bytes.length);
        }
    }
}
